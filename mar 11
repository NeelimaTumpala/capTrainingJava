//Threads->Runnable interface/Numbers->ThreadApp1/ever time we execute we get differeent output
//task/BerthReservation->ReservationAppln
//Join() example using threads/MyRunnable->ThreadsJoinEx/join() used to intimate before ending
//wait()->notify()/Transactions->WaitNotifyExample
//UsingThreadClass
//streams/sorting/Employee->EmployeeList
//streams/sorting/Employee->EmployeeSorting

//Threads->Runnable interface
//Numbers->ThreadApp1
//ever time we execute we get differeent output
package day5;

public class Numbers implements Runnable{

	@Override
	public synchronized void run() {
		System.out.println(Thread.currentThread().getName());
		for(int i=1;i<=5;i++) {
			System.out.print(i+" ");
		}
		
	}

}

//Threads->Runnable interface
//Numbers->ThreadApp1
//ever time we execute we get different output
package day5;

public class ThreadApp1 {

	public static void main(String[] args) {
		Numbers num = new Numbers();
		Thread t1 =new Thread(num);
		Thread t2 =new Thread(num);
		Thread t3 =new Thread(num);
		t1.setName("A");
		t2.setName("B");
		t3.setPriority(Thread.MAX_PRIORITY);
		t3.setName("c");
		t1.start();
		t2.start();
		t3.start();
		

	}

}

//task
//BerthReservation->ReservationAppln
package day5;

import java.util.Scanner;

public class BerthReservation implements Runnable{
	int available = 10;
	
	@Override
	public synchronized void run() {
		Scanner sc = new Scanner(System.in);
		if(available>0) {
			System.out.println("welcome"+Thread.currentThread().getName()+"!!"+
		"Available birth are: "+available);
			System.out.println("Enter the required berths :");
			int a = sc.nextInt();
			available-=a;
			System.out.println(a+" berths allocated to "+Thread.currentThread().getName());
		}else {
			System.out.println("Welcome "+Thread.currentThread().getName()+"!! "
					+ "sorry births are not available...");
		}
			
		
	}
	

}

//task
//BerthReservation->ReservationAppln
package day5;

import java.util.Scanner;

public class ReservationAppln {

	public static void main(String[] args) {
		BerthReservation ber = new BerthReservation();
		Thread t1 = new Thread(ber);
		Thread t2 = new Thread(ber);
		Thread t3 = new Thread(ber);
		Thread t4 = new Thread(ber);
		t1.setName("A");
		t2.setName("B");
		t3.setName("C");
		t4.setName("D");
		
				
		t1.start();
		t2.start();
		t3.start();
		t4.start();
		
	}

}


//Join() example using threads
//MyRunnable->ThreadsJoinEx
//join() used to intimate before ending
package day5;

public class MyRunnable implements Runnable{

	@Override
	public void run() {
		System.out.println("Thread started :: "+Thread.currentThread().getName());
		try {
			Thread.sleep(3000);
		}catch(InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println("Thread ended :: "+Thread.currentThread().getName());
		
	}

}


//wait()->notify()
//Transactions->WaitNotifyExample
package day5;

public class Transactions {
	int available = 5000;
	synchronized void withdraw(int amount) {
		System.out.println("Available balance  = "+this.available);
		System.out.println("trying to withdraw..."+amount);
		if(this.available<amount) {
			System.out.println("Less balance; waiting for deposite... ");
			try {
				wait();
				Thread.sleep(3000);
			}catch(InterruptedException e) {
				e.printStackTrace();
			}
		}
			this.available -=amount;
			System.out.println("withdraw completed...balance is :"+this.available);
		
	}
		synchronized void deposit(int amount) {
			System.out.println("trying to deposite..."+amount);
			this.available+=amount;
			/*try {
				Thread.sleep(3000);
			}catch(InterruptedException e) {
				e.printStackTrace();
			}*/
			System.out.println("deposite completed.. available amount..."+this.available);
			notify();
			
		}
	}

//wait()->notify()
//Transactions->WaitNotifyExample
package day5;

public class WaitNotifyExample {

	public static void main(String[] args) {
		Transactions tran =new Transactions();
		Thread t1= new Thread() {public void run() {tran.withdraw(2000);}};
		Thread t2= new Thread() {public void run() {tran.deposit(5000);}};
		t1.start();
		t2.start();
		
		}

}

//UsingThreadClass
package day5;

public class UsingThreadClass extends Thread{

	
		@Override 
		public synchronized void run() {
			System.out.println(Thread.currentThread());
			for(int i=1;i<5;i++)
				System.out.print(i+" ");
		}
		public static void main(String[] args) {
			UsingThreadClass t1 = new UsingThreadClass();
			UsingThreadClass t2 = new UsingThreadClass();
			t1.start();
			t2.start();
					

	}

}


//streams
//sorting
//Employee->EmployeeList
package day5;

public class Employee {
	private int empcode;
	private String empname;
	private double basicSalary;
	private String city;
	public Employee() {
		
	}
	public Employee(int empcode, String empname, double basicSalary, String city) {
		super();
		this.empcode = empcode;
		this.empname = empname;
		this.basicSalary = basicSalary;
		this.city = city;
	}
	public int getEmpcode() {
		return empcode;
	}
	public void setEmpcode(int empcode) {
		this.empcode = empcode;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public double getBasicSalary() {
		return basicSalary;
	}
	public void setBasicSalary(double basicSalary) {
		this.basicSalary = basicSalary;
	}
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	

}


//streams
//sorting
//Employee->EmployeeList
package day5;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class EmpStreamEx1 {

	public static void main(String[] args) {
		List<Employee> emplist = new ArrayList<Employee>();
		emplist.add(new Employee(14,"kavya",8000,"del"));
		emplist.add(new Employee(15,"hari",9000,"hyd"));
		emplist.add(new Employee(16,"laxmi",10000,"ben"));
		emplist.add(new Employee(17,"saraswathi",11000,"jaipur"));
		
		//exract code from the emplist
		List<Integer> codeList = emplist.stream()
				.map(e->e.getEmpcode())
				.collect(Collectors.toList());
		System.out.println(codeList);
		System.out.println("max value = "+Collections.max(codeList));
		System.out.println("min value = "+Collections.min(codeList));
		System.out.println("check for = "+codeList.contains(11));
		
		
		
		//extract salary from the emplist
		List<Double> salaries = emplist.stream()
				.filter(f->f.getBasicSalary()>8000)
				.map(s->s.getBasicSalary())
				.collect(Collectors.toList());
		System.out.println(salaries);
		//extract the employee object object whose salary is >30000
		List<Employee> salaryList = emplist.stream()
				.filter(f->f.getBasicSalary()>3000)
				.map(m->m)
				.collect(Collectors.toList());
		System.out.println(salaryList);
		salaryList.forEach((e)->System.out.println(e));

	}

}


//streams
//sorting
//Employee->EmployeeSorting
package day5;

public class Employee {
	private int empcode;
	private String empname;
	private double basicSalary;
	private String city;
	public Employee() {
		
	}
	public Employee(int empcode, String empname, double basicSalary, String city) {
		super();
		this.empcode = empcode;
		this.empname = empname;
		this.basicSalary = basicSalary;
		this.city = city;
	}
	public int getEmpcode() {
		return empcode;
	}
	public void setEmpcode(int empcode) {
		this.empcode = empcode;
	}
	public String getEmpname() {
		return empname;
	}
	public void setEmpname(String empname) {
		this.empname = empname;
	}
	public double getBasicSalary() {
		return basicSalary;
	}
	public void setBasicSalary(double basicSalary) {
		this.basicSalary = basicSalary;
	}
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	

}


//streams
//sorting
//Employee->EmployeeSorting
package day5;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

public class EmployeeSorting {

	public static void main(String[] args) {
		List<Employee> emplist = new ArrayList<Employee>();
		emplist.add(new Employee(14,"kavya",8000,"del"));
		emplist.add(new Employee(15,"hari",9000,"hyd"));
		emplist.add(new Employee(16,"laxmi",10000,"ben"));
		emplist.add(new Employee(17,"saraswathi",11000,"jaipur"));
		/*Collections.sort(emplist,(e1,e2)->{
			return e1.getEmpcode()-e2.getEmpcode();
		});*/
		/*emplist.stream().sorted((e1,e2)->{
			return e1.getEmpname().compareTo(e2.getEmpname());
		});*/
		List<Employee> sortedList = emplist.stream().sorted((e1,e2)->{
			return e1.getEmpname().compareTo(e2.getEmpname());})
				.map(e->e)
				.collect(Collectors.toList());
		
		emplist.forEach((e)->System.out.println(e.getEmpcode()+e.getEmpname()));
		System.out.println();
		sortedList.forEach((e)->System.out.println(e.getEmpcode()+e.getEmpname()));

	}

}
